From 93bc1338624ed8e87f939e7aacc88a2acbf27aa2 Mon Sep 17 00:00:00 2001
From: Your Name <you@example.com>
Date: Wed, 13 Aug 2025 10:09:37 +0000
Subject: [PATCH] Support CUDA 13

---
 modules/core/src/cuda_info.cpp | 41 +++++++++++++++++++++++++---------
 1 file changed, 31 insertions(+), 10 deletions(-)

diff --git a/modules/core/src/cuda_info.cpp b/modules/core/src/cuda_info.cpp
index 2558ec8ea5..4ad4cf9340 100644
--- a/modules/core/src/cuda_info.cpp
+++ b/modules/core/src/cuda_info.cpp
@@ -424,7 +424,9 @@ int cv::cuda::DeviceInfo::clockRate() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->clockRate;
+    int clockRate;
+    cudaSafeCall(cudaDeviceGetAttribute(&clockRate, cudaDevAttrClockRate, device_id_));
+    return clockRate;
 #endif
 }
 
@@ -487,7 +489,9 @@ bool cv::cuda::DeviceInfo::kernelExecTimeoutEnabled() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->kernelExecTimeoutEnabled != 0;
+    int kernelExecTimeoutEnabled;
+    cudaSafeCall(cudaDeviceGetAttribute(&kernelExecTimeoutEnabled, cudaDevAttrKernelExecTimeout, device_id_));
+    return kernelExecTimeoutEnabled != 0;
 #endif
 }
 
@@ -522,7 +526,9 @@ DeviceInfo::ComputeMode cv::cuda::DeviceInfo::computeMode() const
         ComputeModeExclusiveProcess
     };
 
-    return tbl[deviceProps().get(device_id_)->computeMode];
+    int computeMode;
+    cudaSafeCall(cudaDeviceGetAttribute(&computeMode, cudaDevAttrComputeMode, device_id_));
+    return tbl[computeMode];
 #endif
 }
 
@@ -554,7 +560,14 @@ int cv::cuda::DeviceInfo::maxTexture1DLinear() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->maxTexture1DLinear;
+    #if CUDA_VERSION >= 13000
+        size_t maxWidthInElements;
+        cudaChannelFormatDesc fmtDesc = cudaCreateChannelDesc<float4>();
+        cudaSafeCall(cudaDeviceGetTexture1DLinearMaxWidth(&maxWidthInElements, &fmtDesc, device_id_));
+        return maxWidthInElements;
+    #else
+        return deviceProps().get(device_id_)->maxTexture1DLinear;
+    #endif
 #endif
 }
 
@@ -793,7 +806,9 @@ int cv::cuda::DeviceInfo::memoryClockRate() const
 #ifndef HAVE_CUDA
     throw_no_cuda();
 #else
-    return deviceProps().get(device_id_)->memoryClockRate;
+    int memoryClockRate;
+    cudaSafeCall(cudaDeviceGetAttribute(&memoryClockRate, cudaDevAttrMemoryClockRate, device_id_));
+    return memoryClockRate;
 #endif
 }
 
@@ -933,8 +948,9 @@ void cv::cuda::printCudaDeviceInfo(int device)
         if (cores > 0)
             printf("  (%2d) Multiprocessors x (%2d) CUDA Cores/MP:     %d CUDA Cores\n", prop.multiProcessorCount, cores, cores * prop.multiProcessorCount);
 
-        printf("  GPU Clock Speed:                               %.2f GHz\n", prop.clockRate * 1e-6f);
-
+        int clockRate;
+        cudaSafeCall(cudaDeviceGetAttribute(&clockRate, cudaDevAttrClockRate, dev));
+        printf("  GPU Clock Speed:                               %.2f GHz\n", clockRate * 1e-6f);
         printf("  Max Texture Dimension Size (x,y,z)             1D=(%d), 2D=(%d,%d), 3D=(%d,%d,%d)\n",
             prop.maxTexture1D, prop.maxTexture2D[0], prop.maxTexture2D[1],
             prop.maxTexture3D[0], prop.maxTexture3D[1], prop.maxTexture3D[2]);
@@ -952,8 +968,10 @@ void cv::cuda::printCudaDeviceInfo(int device)
         printf("  Maximum memory pitch:                          %u bytes\n", (int)prop.memPitch);
         printf("  Texture alignment:                             %u bytes\n", (int)prop.textureAlignment);
 
-        printf("  Concurrent copy and execution:                 %s with %d copy engine(s)\n", (prop.deviceOverlap ? "Yes" : "No"), prop.asyncEngineCount);
-        printf("  Run time limit on kernels:                     %s\n", prop.kernelExecTimeoutEnabled ? "Yes" : "No");
+        printf("  Concurrent copy and execution:                 %s with %d copy engine(s)\n", (prop.asyncEngineCount ? "Yes" : "No"), prop.asyncEngineCount);
+        int kernelExecTimeoutEnabled;
+        cudaSafeCall(cudaDeviceGetAttribute(&kernelExecTimeoutEnabled, cudaDevAttrKernelExecTimeout, dev));
+        printf("  Run time limit on kernels:                     %s\n", kernelExecTimeoutEnabled ? "Yes" : "No");
         printf("  Integrated GPU sharing Host Memory:            %s\n", prop.integrated ? "Yes" : "No");
         printf("  Support host page-locked memory mapping:       %s\n", prop.canMapHostMemory ? "Yes" : "No");
 
@@ -963,8 +981,11 @@ void cv::cuda::printCudaDeviceInfo(int device)
         printf("  Device is using TCC driver mode:               %s\n", prop.tccDriver ? "Yes" : "No");
         printf("  Device supports Unified Addressing (UVA):      %s\n", prop.unifiedAddressing ? "Yes" : "No");
         printf("  Device PCI Bus ID / PCI location ID:           %d / %d\n", prop.pciBusID, prop.pciDeviceID );
+
+        int propComputeMode;
+        cudaSafeCall(cudaDeviceGetAttribute(&propComputeMode, cudaDevAttrComputeMode, dev));
         printf("  Compute Mode:\n");
-        printf("      %s \n", computeMode[prop.computeMode]);
+        printf("      %s \n", computeMode[propComputeMode]);
     }
 
     printf("\n");
-- 
2.43.0

